package slp;

import java_cup.runtime.*;

parser code  {:
	/** Causes the parsr to print every token it reads.
	 * This is useful for debugging.
	 */
	public boolean printTokens;
	
	private Lexer lexer;

	public Parser(Lexer lexer) {
		super(lexer);
		this.lexer = lexer;
	}
	                 
	public int getLine() {
		return lexer.getLineNumber();
	}
	
	public void syntax_error(Symbol s) {
		Token tok = (Token) s;
		System.out.println("\nLine " + tok.getLine()+": Syntax error. unexpected token: " + tok.toString());
	}
	
	public static void print_rule(String rule_text) {
		//System.out.print("\nReduced rule: " + rule_text);
	}
:}  

// This is just for debugging
scan with {:
	Token t = (Token)lexer.next_token();
	if (printTokens)
		System.out.println(t.getLine() + ":" + t);
	return t; 
:};

terminal String		PLUS, MINUS,UMINUS, MULTIPLY, DIVIDE, SEMI, ASSIGN,
					GT, LT, LAND, LOR;
terminal String 	CLASS_ID, ID, QUOTE;
terminal String		INT, DOT, WHILE,  STATIC,
					CONTINUE, LB, MOD, GTE, LTE, EQUAL, IF, TRUE, LNEG, 
					LP, RETURN, COMMA, RCBR, NULL, LENGTH, RB, FALSE, VOID, 
					 ELSE, THIS, NEQUAL,  STRING, LCBR, EXTENDS, 
					RP, NEW, BREAK, CLASS;
terminal			BOOLEAN, INTEGER;

non terminal ASTExpr 		expr, maby_expr, assign_exp;
non terminal ASTStmt 		stmt, else_stmnt, call, staticCall, virtualCall;
non terminal Operator		binop, unop;
non terminal ASTStmtList 	stmt_list;
non terminal ASTfmList		field_meth_list;
non terminal ASTClassList	classDecl_list;
non terminal ASTFormalList	formals, maybe_formals;
non terminal ASTRoot		program;
non terminal ASTClassDecl 	classDecl;
non terminal ASTIdList		id_list;
non terminal ASTExtend		extend;
non terminal ASTStatType	stat_type_void;
non terminal String 	type;
non terminal ASTNode 	method,  
						field_meth, field,
						 expr_list, location, 
						literal;

precedence right ASSIGN; 
precedence left LOR;
precedence left LAND;
precedence left EQUAL, NEQUAL;
precedence left GT, LT, GTE, LTE;
precedence left PLUS, MINUS;
precedence left DIVIDE, MULTIPLY, MOD;
precedence right LNEG, UMINUS;
precedence left ELSE;
precedence left LB, RB, LP, RP, DOT;


program ::= classDecl_list:c1
		{:  RESULT = new ASTRoot("program", c1);
		Parser.print_rule("program-> 'classDecl_list'"); :}
;

classDecl_list ::= classDecl_list:cl1 classDecl:c1
		{: cl1.addNode(c1); 
		RESULT = cl1;
		Parser.print_rule("classDecl_list-> 'cl1 c1' for cl1=" + cl1 + " and c1=" + c1); :}
		| /*empty*/
		{:  RESULT = new ASTClassList();
		Parser.print_rule("classDecl_list-> 'empty'"); :}
; 

classDecl ::= CLASS CLASS_ID:c1 extend:e1 LCBR field_meth_list:fml RCBR
		{: RESULT = new ASTClassDecl(c1, e1, fml);
		Parser.print_rule("classDecl_list-> 'class c1 e1 {fields_and_methods}' for c1=" + c1 + " and e1=" + e1); :}
;

extend ::= /*empty*/
		{: RESULT = new ASTExtend();
		Parser.print_rule("extend-> ''"); :} 
		| EXTENDS CLASS_ID:c1
		{: RESULT = new ASTExtend(c1);
		Parser.print_rule("extend-> 'extends c1' for c1=" + c1); :} 
;

field_meth_list ::= /**/
		{: RESULT = new ASTfmList();
		Parser.print_rule("field_meth_list-> 'field_meth'"); :} 
		| field_meth_list:fml field_meth:fm
		{: fml.addNode(fm); RESULT = fml;
		Parser.print_rule("field_meth_list-> 'field_meth_list field_meth'"); :} 
;

field_meth ::= field:f1
		{: RESULT = f1;
		Parser.print_rule("field_meth-> 'field'"); :} 
		 | method:m1
		{: RESULT = m1;
		Parser.print_rule("field_meth-> 'method'"); :} 
;

field ::= type:t1 id_list:is1 SEMI
		{: RESULT = new ASTField(t1, is1);
		Parser.print_rule("field-> 't1 is1;' for t1=" + t1 + ", is1="+is1); :}
;

id_list ::= ID:i1
		{: RESULT = new ASTIdList(i1);
		Parser.print_rule("id_list-> 'i1' for i1="+i1); :}
		| id_list:is1 COMMA ID:i1
		{: is1.addNode(i1); RESULT = is1 ;
		Parser.print_rule("id_list-> 'is1, i1' for is1=" + is1 + ", i1="+i1); :}
;

method ::= stat_type_void:st1 LP maybe_formals:mf1 RP LCBR stmt_list:sl1 RCBR
		{: RESULT = new ASTMethod(st1.isStatic, st1.type, st1.id, mf1, sl1); 
		Parser.print_rule("stat_type_void-> 'st1 (maybe_formals) {stmt_list}' for st1="+st1); :} 
;

stat_type_void::= STATIC type:t1 ID:i1
		{: RESULT = new ASTStatType(true, t1, i1); 
		Parser.print_rule("stat_type_void-> 'static t1 i1' for t1="+t1+" and i1="+i1); :}
		| type:t1 ID:i1
		{:RESULT = new ASTStatType(false, t1, i1); 
		Parser.print_rule("stat_type_void-> 't1 i1' for t1="+t1+" and i1="+i1); :}
		| STATIC VOID ID:i1
		{: RESULT = new ASTStatType(true, Keyword.VOID.toString(), i1); 
		Parser.print_rule("stat_type_void-> 'static void i1' for i1="+i1); :} 
		| VOID ID:i1
		{: RESULT = new ASTStatType(false, Keyword.VOID.toString(), i1); 
		Parser.print_rule("stat_type_void-> 'void i1' for i1="+i1); :} 
; 


type ::= INT 
		{: RESULT = Keyword.INT.toString();
		Parser.print_rule("type-> 'INT'"); :}
		| BOOLEAN
		{: RESULT = Keyword.BOOLEAN.toString();
		Parser.print_rule("type-> 'BOOLEAN'"); :}
		| STRING 
		{: RESULT = Keyword.STRING.toString();
		Parser.print_rule("type-> 'STRING'"); :}
		| CLASS_ID:c1  
		{: RESULT = c1;
		Parser.print_rule("type-> 'c1' for c1="+c1); :}
		| type:t1 LB RB
		{: RESULT = t1 + "[]";
		Parser.print_rule("type-> 't1[]' for t1="+t1); :}
;

maybe_formals ::= /*empty*/ 
		{: RESULT = new ASTFormalList();
		Parser.print_rule("maybe_formals-> ''"); :} 
		| formals:fl1
		{: RESULT = fl1;
		  Parser.print_rule("maybe_formals-> 'fl1' for fl1=" + fl1); :} 
;

formals ::= type:t1 ID:i1
		{:  RESULT = new ASTFormalList(t1, i1); 
		Parser.print_rule("formals-> 't1 i1' for t1="+t1+" and i1="+i1); :}
		| type:t1 ID:i1 COMMA formals:fl1
		{: fl1.addNode(t1, i1); RESULT = fl1;
		Parser.print_rule("formals-> 't1 i1, fl1' for t1="+t1+" and i1="+i1+" and fl1="+fl1); :}
;

stmt_list ::= /*empty*/
	{: RESULT = new ASTStmtList();  :}
	| stmt_list:sl stmt:s
	{: sl.addNode(s); RESULT = sl; :}
;
 
stmt ::= location:v ASSIGN expr:e SEMI
	{: RESULT = new ASTAssignStmt(v, e);
	Parser.print_rule("stmt -> 'v=e;' for v: " + v + "and e :" + e); :}
	| call:cl SEMI
	{: RESULT = cl; :}
	| RETURN maby_expr:e1 SEMI
	{:RESULT = new ASTRetExp(e1); 
	Parser.print_rule("stmt -> 'return e1' for: " + e1);:}
	| IF LP expr:ex1 RP stmt:s1 else_stmnt:el1 
	{: RESULT = new ASTIfElseStmt(ex1, s1, el1); 
	 	:}
	| WHILE LP expr:e1 RP stmt:s1
	{:  RESULT = new ASTWhileStmt(e1,s1);
		Parser.print_rule("stmt -> 'while e1' for: " + e1);:}
	| BREAK SEMI
	{: RESULT = new ASTVarStmt(Keyword.BREAK.toString());
		Parser.print_rule("stmt -> 'break;'");:}
	| CONTINUE SEMI
	{: RESULT = new ASTVarStmt(Keyword.CONTINUE.toString());
		Parser.print_rule("stmt -> 'continue;'");:}	
	| LCBR stmt_list:st RCBR 
	{:RESULT = st;:}  
	| type:t1 ID:i1 assign_exp:e1 SEMI 
	{: Formal f1 = new Formal(t1, i1);
	   RESULT = new ASTAssignFormals(f1,e1);
	 Parser.print_rule("stmt -> t1 i1 = e1  for t1: " + t1 + ", i1: " + i1 + ", e1: " + e1);:}
;

else_stmnt ::= /*empty*/ {: RESULT = null;:} |
				 ELSE stmt:st
				 {: RESULT = new ASTElseStmt(st);
				 	 Parser.print_rule("else statement");:}
; 
assign_exp ::= /*empty*/  
		{: RESULT = null;:} 
		| ASSIGN expr:e1
		{: RESULT = new ASTAssignStmt(e1);
		   Parser.print_rule("assign_exp-> '=e1' for e1="+e1); :} 
;

maby_expr ::= /*empty*/ 
		{: RESULT = null;:} 
		| expr:e1
		{: RESULT = e1; :}
;

expr ::= location
		{: RESULT = new ASTVarExpr("");
		:}
		|
		call:c1
		{: RESULT = new ASTVarExpr("");
		/*RESULT = new Call(c1);*/
		:}
		| THIS
		{: RESULT = new ASTVarExpr(Keyword.THIS.toString());
		:}
		| NEW CLASS_ID:cid LP RP 
		{: RESULT = new ASTVarExpr("");
		:}
		| NEW type:t LB expr RB
		{:  RESULT = new ASTVarExpr("");
		:}
		| expr:e1 DOT LENGTH
		{:  RESULT = new ASTVarExpr("");
		:}
		| expr:e1 binop:b expr:e2
		{: RESULT = new ASTBinaryOpExpr(e1, e2, b);
		:}  
		| unop:u expr:e
		{: RESULT = new ASTUnaryOpExpr(e,u);
		:}
		| literal:l
		{: RESULT = new ASTVarExpr("");
		:}
		| LP expr:e RP
		{: RESULT = new ASTVarExpr("");
		:}
;

	  
	
call ::= staticCall:m1 
		{: Parser.print_rule("Call -> m1 for m1: " + m1); :}
		| virtualCall:vm
		{: Parser.print_rule("Call -> m1 for vm: " + vm); :}
;

staticCall ::= CLASS_ID:ci1 DOT ID:i1 LP expr_list:e2 RP
		{: Parser.print_rule("staticCall -> 'ci1.i1 (e2)' for ci1=" + ci1 + ", i1="+i1); :}
;

expr_list ::= /*empty*/ | expr | expr_list COMMA expr
;

virtualCall ::= expr:e1 DOT ID:i1 LP expr_list:e2 RP
		{: Parser.print_rule("virtualCall -> 'e1.i1(e2)' for i1="+i1); :}
		 | ID:i1 LP expr_list:e2 RP
		{: Parser.print_rule("virtualCall -> 'i1(e2)' for i1="+i1); :}
;

location ::= ID | expr DOT ID | expr LB expr RB
;

binop ::= PLUS 
		{: RESULT = Operator.PLUS; :} 
		| MINUS 
		{: RESULT = Operator.MINUS; :} 
		| MULTIPLY 
		{: RESULT = Operator.MULTIPLY; :} 
		| DIVIDE 
		{: RESULT = Operator.DIV; :} 
		| LAND 
		{: RESULT = Operator.LAND; :} 
		| LOR 
		{: RESULT = Operator.LOR; :} 
		| GT 
		{: RESULT = Operator.GT; :} 
		| LT 
		{: RESULT = Operator.LT; :} 
		| GTE 
		{: RESULT = Operator.GTE; :} 
		| LTE 
		{: RESULT = Operator.LTE; :} 
		| EQUAL 
		{: RESULT = Operator.EQUAL; :} 
		| NEQUAL 
		{: RESULT = Operator.NEQUAL; :} 
		| MOD
		{: RESULT = Operator.MOD; :} 
;  

unop ::= MINUS 
		{: RESULT = Operator.MINUS; :} 
		| LNEG
		{: RESULT = Operator.LNEG; :} 
;

literal ::= INTEGER | QUOTE | TRUE | FALSE | NULL
;
