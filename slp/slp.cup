package slp;

import java_cup.runtime.*;

parser code  {:
	/** Causes the parsr to print every token it reads.
	 * This is useful for debugging.
	 */
	public boolean printTokens;
	
	private Lexer lexer;

	public Parser(Lexer lexer) {
		super(lexer);
		this.lexer = lexer;
	}
	
	public int getLine() {
		return lexer.getLineNumber();
	}
	
	public void syntax_error(Symbol s) {
		Token tok = (Token) s;
		System.out.println("\nLine " + tok.getLine()+": Syntax error. unexpected token: " + tok.toString());
	}
:}  

// This is just for debugging
scan with {:
	Token t = (Token)lexer.next_token();
	if (printTokens)
		System.out.println(t.getLine() + ":" + t);
	return t; 
:};

terminal 			PLUS, MINUS, MULT, DIVIDE, LPAREN, RPAREN, SEMI, ASSIGN,
					GT, LT, GE, LE, LAND, LOR;
terminal Integer 	NUMBER; //TODO - i dont know how ints work 
terminal String 	CLASS_ID, ID;
terminal 			UMINUS;
terminal 			INT, DOT, WHILE,  STATIC, MULTIPLY, INTEGER,
					CONTINUE, LB, MOD, GTE, LTE, EQUAL, IF, TRUE, LNEG, 
					LP, RETURN, COMMA, RCBR, NULL, LENGTH, RB, FALSE, VOID, 
					BOOLEAN, ELSE, THIS, NEQUAL,  STRING, LCBR, EXTENDS, 
					RP, QUOTE, NEW, BREAK, CLASS;

non terminal Expr 		expr;
non terminal Stmt 		stmt;
non terminal StmtList 	stmt_list;
non terminal 			program, classDecl_list, classDecl, extend, field_meth, 
						field_meth_end, field, id_list,	method, maybe_formals, 
						formals, stat_type_void, type_void, type,
						call, staticCall, expr_list, virtualCall, location, 
						binop, unop, literal;



 
 
precedence left LOR;
precedence left LAND;
precedence left PLUS, MINUS;
precedence left DIVIDE, MULT;
precedence left UMINUS;
precedence left GT, LT, GE, LE;

program ::= classDecl_list
;

classDecl_list ::= classDecl classDecl
; 

classDecl ::= CLASS CLASS_ID extend LCBR field_meth RCBR
;

extend ::= /*empty*/ | EXTENDS CLASS_ID
;

field_meth ::= field_meth_end | field_meth field_meth_end
;

field_meth_end ::= field | method
;

field ::= type id_list SEMI
;

id_list ::= ID | id_list COMMA ID
;

method ::= stat_type_void maybe_formals RP LCBR stmt_list RCBR
;

stat_type_void::= STATIC type ID LP | type ID LP
					| STATIC VOID ID LP | VOID ID LP
; 


type ::= INT | BOOLEAN | STRING | CLASS | type LB RB
;

maybe_formals ::= /*empty*/ | formals
;

formals ::= type ID | type ID COMMA formals
;

stmt_list ::= stmt:s
	{: RESULT = new StmtList(s); :}
	| stmt_list:sl stmt:s
	{: sl.addStmt(s); RESULT = sl; :}
;

stmt ::= ID:v ASSIGN expr:e SEMI
	{: VarExpr ve = new VarExpr(v); RESULT = new AssignStmt(ve, e); :}
	| expr:e
;

expr ::= expr:e1 PLUS:p expr:e2
		{: RESULT = new BinaryOpExpr(e1, e2, Operator.PLUS);
		   System.out.println("Reduced rule e1 + e2 for e1=" + e1 + " and e2="+e2);
		 :}
		| expr:e1 MINUS expr:e2
		{: RESULT = new BinaryOpExpr(e1, e2, Operator.MINUS);
		   System.out.println("Reduced rule e1 - e2 for e1=" + e1 + " and e2="+e2);
		 :}
		| expr:e1 MULT expr:e2
		{: RESULT = new BinaryOpExpr(e1, e2, Operator.MULT);
		   System.out.println("Reduced rule e1 * e2 for e1=" + e1 + " and e2="+e2);
		 :}
		| expr:e1 DIVIDE expr:e2
		{: RESULT = new BinaryOpExpr(e1, e2, Operator.DIV);
		   System.out.println("Reduced rule e1 / e2 for e1=" + e1 + " and e2="+e2);
		 :}
		| expr:e1 LAND expr:e2
		{: RESULT = new BinaryOpExpr(e1, e2, Operator.LAND);
		   System.out.println("Reduced rule e1 && e2 for e1=" + e1 + " and e2="+e2);
		 :}
		| expr:e1 LOR expr:e2
		{: RESULT = new BinaryOpExpr(e1, e2, Operator.LOR);
		   System.out.println("Reduced rule e1 || e2 for e1=" + e1 + " and e2="+e2);
		 :}
		| expr:e1 LT expr:e2
		{: RESULT = new BinaryOpExpr(e1, e2, Operator.LT);
		   System.out.println("Reduced rule e1 < e2 for e1=" + e1 + " and e2="+e2);
		 :}
		| expr:e1 GT expr:e2
		{: RESULT = new BinaryOpExpr(e1, e2, Operator.GT);
		   System.out.println("Reduced rule e1 > e2 for e1=" + e1 + " and e2="+e2);
		 :}
		| expr:e1 LE expr:e2
		{: RESULT = new BinaryOpExpr(e1, e2, Operator.LE);
		   System.out.println("Reduced rule e1 <= e2 for e1=" + e1 + " and e2="+e2);
		 :}
		| expr:e1 GE expr:e2
		{: RESULT = new BinaryOpExpr(e1, e2, Operator.GE);
		   System.out.println("Reduced rule e1 >= e2 for e1=" + e1 + " and e2="+e2);
		 :}
		| MINUS expr:e1
		{: RESULT = new UnaryOpExpr(e1, Operator.MINUS); :} %prec UMINUS
		| LPAREN expr:e RPAREN
		{: RESULT = e; :}
		| NUMBER:n
		{: RESULT = new NumberExpr(n.intValue()); :}
		| ID:v
		{: RESULT = new VarExpr(v); :}
;
	
	
call ::= staticCall | virtualCall
;

staticCall ::= CLASS DOT ID LP expr_list RP
;

expr_list ::= expr | expr_list expr
;

virtualCall ::= expr DOT ID LP expr_list RP |ID LP expr_list RP
;

location ::= ID | expr DOT ID | expr LB expr RB
;

binop ::= PLUS | MINUS | MULT | DIVIDE | MOD | LAND | LOR | 
			GT | LT | GTE | LTE | EQUAL | NEQUAL
;  

unop ::= MINUS | LNEG
;

literal ::= INTEGER | STRING | TRUE | FALSE | NULL
;
