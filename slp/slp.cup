package slp;

import java_cup.runtime.*;

parser code  {:
	/** Causes the parsr to print every token it reads.
	 * This is useful for debugging.
	 */
	public boolean printTokens;
	
	private Lexer lexer;

	public Parser(Lexer lexer) {
		super(lexer);
		this.lexer = lexer;
	}
	                 
	public int getLine() {
		return lexer.getLineNumber();
	}
	
	public void syntax_error(Symbol s) {
		Token tok = (Token) s;
		System.out.println("\nLine " + tok.getLine()+": Syntax error. unexpected token: " + tok.toString());
	}
	
	public static void print_rule(String rule_text) {
		System.out.print("\nReduced rule: " + rule_text);
	}
:}  

// This is just for debugging
scan with {:
	Token t = (Token)lexer.next_token();
	if (printTokens)
		System.out.println(t.getLine() + ":" + t);
	return t; 
:};

terminal 			PLUS, MINUS, MULTIPLY, DIVIDE, SEMI, ASSIGN,
					GT, LT, LAND, LOR;
terminal String 	CLASS_ID, ID, QUOTE;
terminal 			INT, DOT, WHILE,  STATIC, INTEGER,
					CONTINUE, LB, MOD, GTE, LTE, EQUAL, IF, TRUE, LNEG, 
					LP, RETURN, COMMA, RCBR, NULL, LENGTH, RB, FALSE, VOID, 
					BOOLEAN, ELSE, THIS, NEQUAL,  STRING, LCBR, EXTENDS, 
					RP, NEW, BREAK, CLASS;

non terminal Expr 		expr;
non terminal Stmt 		stmt;
non terminal StmtList 	stmt_list;
non terminal String 	type, id_list, classDecl, classDecl_list,method, extend, stat_type_void, formals;
non terminal 			program, field_meth_list, maby_expr,
						field_meth, field, maybe_formals, 
						call, staticCall, expr_list, virtualCall, location, 
						binop, unop, literal, else_stmnt, assign_exp;

precedence right ASSIGN; 
precedence left LOR;
precedence left LAND;
precedence left EQUAL, NEQUAL;
precedence left GT, LT, GTE, LTE;
precedence left PLUS, MINUS;
precedence left LNEG;
precedence left DIVIDE, MULTIPLY, MOD;
precedence left ELSE;
precedence left LB, RB, LP, RP, DOT;


program ::= classDecl_list
		{: Parser.print_rule("program-> 'classDecl_list'"); :}
;

classDecl_list ::= classDecl_list:cl1 classDecl:c1
		{: Parser.print_rule("classDecl_list-> 'cl1 c1' for cl1=" + cl1 + " and c1=" + c1); :}
		| /*empty*/
		{: Parser.print_rule("classDecl_list-> 'empty'"); :}
; 

classDecl ::= CLASS CLASS_ID:c1 extend:e1 LCBR field_meth_list RCBR
		{: RESULT = c1;
		Parser.print_rule("classDecl_list-> 'class c1 e1 {fields_and_methods}' for c1=" + c1 + " and e1=" + e1); :}
;

extend ::= /*empty*/
		{: RESULT = "";
		Parser.print_rule("extend-> ''"); :} 
		| EXTENDS CLASS_ID:c1
		{: RESULT = "extends "+c1; 
		Parser.print_rule("extend-> 'extends c1' for c1=" + c1); :} 
;

field_meth_list ::= field_meth 
		{: Parser.print_rule("field_meth_list-> 'field_meth'"); :} 
		| field_meth_list field_meth
		{: Parser.print_rule("field_meth_list-> 'field_meth_list field_meth'"); :} 
;

field_meth ::= field
		{: Parser.print_rule("field_meth-> 'field'"); :} 
		 | method
		{: Parser.print_rule("field_meth-> 'method'"); :} 
;

field ::= type:t1 id_list:is1 SEMI
		{: Parser.print_rule("field-> 't1 is1;' for t1=" + t1 + ", is1="+is1); :}
;

id_list ::= ID:i1
		{: RESULT = i1;
		Parser.print_rule("id_list-> 'i1' for i1="+i1); :}
		| id_list:is1 COMMA ID:i1
		{: RESULT = is1 + ", " + i1; 
		Parser.print_rule("id_list-> 'is1, i1' for is1=" + is1 + ", i1="+i1); :}
;

method ::= stat_type_void:st1 LP maybe_formals RP LCBR stmt_list RCBR
		{: RESULT = st1;
		Parser.print_rule("stat_type_void-> 'st1 (maybe_formals) {stmt_list}' for st1="+st1); :} 
;

stat_type_void::= STATIC type:t1 ID:i1
		{: RESULT = i1;
		Parser.print_rule("stat_type_void-> 'static t1 i1' for t1="+t1+" and i1="+i1); :}
		| type:t1 ID:i1
		{: RESULT = i1;
		Parser.print_rule("stat_type_void-> 't1 i1' for t1="+t1+" and i1="+i1); :}
		| STATIC VOID ID:i1
		{: RESULT = i1;
		Parser.print_rule("stat_type_void-> 'static void i1' for i1="+i1); :} 
		| VOID ID:i1
		{: RESULT = i1;
		Parser.print_rule("stat_type_void-> 'void i1' for i1="+i1); :} 
; 


type ::= INT 
		{: RESULT = "INT";
		Parser.print_rule("type-> 'INT'"); :}
		| BOOLEAN
		{: RESULT = "BOOLEAN";
		Parser.print_rule("type-> 'BOOLEAN'"); :}
		| STRING 
		{: RESULT = "STRING";
		Parser.print_rule("type-> 'STRING'"); :}
		| CLASS_ID:c1 
		{: RESULT = c1;
		Parser.print_rule("type-> 'c1' for c1="+c1); :}
		| type:t1 LB RB
		{: RESULT = t1 + "[]";
		Parser.print_rule("type-> 't1[]' for t1="+t1); :}
;

maybe_formals ::= /*empty*/ 
		{: Parser.print_rule("maybe_formals-> ''"); :} 
		| formals:fl1
		{: Parser.print_rule("maybe_formals-> 'fl1' for fl1=" + fl1); :} 
;

formals ::= type:t1 ID:i1
		{: RESULT = t1 + " " + i1;
		Parser.print_rule("formals-> 't1 i1' for t1="+t1+" and i1="+i1); :}
		| type:t1 ID:i1 COMMA formals:fl1
		{: RESULT = t1 + " " + i1 + ", " + fl1;
		Parser.print_rule("formals-> 't1 i1, fl1' for t1="+t1+" and i1="+i1+" and fl1="+fl1); :}
;

stmt_list ::= /*empty*/
	{:  :}
	| stmt_list:sl stmt:s
	{: /*sl.addStmt(s); RESULT = sl; */:}
;

stmt ::= location:v ASSIGN expr:e SEMI
	{: /*VarExpr ve = new VarExpr(v); RESULT = new AssignStmt(ve, e);*/
	Parser.print_rule("stmt -> 'v=e;' for v: " + v + "and e :" + e); :}
	| call SEMI
	| RETURN maby_expr:e1 SEMI
	{: Parser.print_rule("stmt -> 'return e1' for: " + e1);:}
	| IF LP expr:e1 RP stmt else_stmnt 
	{: Parser.print_rule("stmt -> 'if e1' for: " + e1);:}
	| WHILE LP expr:e1 RP stmt
	{: Parser.print_rule("stmt -> 'while e1' for: " + e1);:}
	| BREAK SEMI
	{: Parser.print_rule("stmt -> 'break;'");:}
	| CONTINUE SEMI
	{: Parser.print_rule("stmt -> 'continue;'");:}
	| LCBR stmt_list RCBR 
	| type:t1 ID:i1 assign_exp:e1 SEMI
	{: Parser.print_rule("stmt -> t1 i1 = e1  for t1: " + t1 + ", i1: " + i1 + ", e1: " + e1);:}
;

else_stmnt ::= /*empty*/ |
				 ELSE stmt
				 {: Parser.print_rule("else statement");:}
;
assign_exp ::= /*empty*/ 
		| ASSIGN expr:e1
		{: Parser.print_rule("assign_exp-> '=e1' for e1="+e1); :} 
;

maby_expr ::= /*empty*/ 
		| expr:e1
;

expr ::= location
		|
		call:c1
		{: /*RESULT = new Call(c1);*/
		:}
		| THIS
		{: /*RESULT = THIS*/
		:}
		| NEW CLASS_ID:cid LP RP 
		{: 
		:}
		| NEW type:t LB expr RB
		{: 
		:}
		| expr:e1 DOT LENGTH
		{: 
		:}
		| expr:e1 binop:o expr:e2
		{: 
		:}
		| unop:u expr:e
		{: /*RESULT = new UnaryOpExpr(e,u);*/
		:}
		| literal:l
		{:
		:}
		| LP expr:e RP
		{:
		:}
;

	  
	
call ::= staticCall:m1 
		{: Parser.print_rule("Call -> m1 for m1: " + m1); :}
		| virtualCall:vm
		{: Parser.print_rule("Call -> m1 for vm: " + vm); :}
;

staticCall ::= CLASS_ID:ci1 DOT ID:i1 LP expr_list:e2 RP
		{: Parser.print_rule("staticCall -> 'ci1.i1 (e2)' for ci1=" + ci1 + ", i1="+i1); :}
;

expr_list ::= /*empty*/ | expr | expr_list COMMA expr
;

virtualCall ::= expr:e1 DOT ID:i1 LP expr_list:e2 RP
		{: Parser.print_rule("virtualCall -> 'e1.i1(e2)' for i1="+i1); :}
		 | ID:i1 LP expr_list:e2 RP
		{: Parser.print_rule("virtualCall -> 'i1(e2)' for i1="+i1); :}
;

location ::= ID | expr DOT ID | expr LB expr RB
;

binop ::= PLUS | MINUS | MULTIPLY | DIVIDE | LAND | LOR | 
			GT | LT | GTE | LTE | EQUAL | NEQUAL | MOD
;  

unop ::= MINUS | LNEG
;

literal ::= INTEGER | QUOTE | TRUE | FALSE | NULL
;
